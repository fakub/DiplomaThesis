%!% udělat chapter? Principles nebo Concepts?
\section{Basic Cryptography Concepts}
\label{sec:cryptobasics}

\subsection{The Goal of Cryptography}

% goal: introduce crypto in a broader context, yet not too much in detail
% starý jako lidstvo samo, bla bla, trochu ukázky z historie a jak to bylo špatný a jak se to umí lámat, security by obscurity, využívá cool matiku
% co po crypto vlastně chci
%~ effective algorithm, uniformly random: $k\xleftarrow{R}K$.
%~ crypto = basis for security mechanisms
%~ CONFIDENTIALITY and much more (e.g. integrity, digital signature, anonymity) or magic: zero knowledge proof of knowledge, FHE
%~  or a complicated construction of crypto primitives (e.g. digital currency, electronic election, electronic auction)
%~ 1. threat model (WB vs. BB later)
%~ 2. propose sth
%~ 3. prove that breaking it would break an underlying hard problem
%~ security by obscurity, on the other hand the useful approach
%~ PRF/PRP, black-box ...

% bla bla ...

Let us imagine a typical situation where Alice wants to talk to Bob over an insecure channel while Eve may eavesdrop on the channel. In the beginning, let us suppose that Alice and Bob share certain portion of secret information referred to as {\em secret key} and both control a secure execution environment where they intend to run their ciphering algorithm so that Eve can only observe what they send over the channel.

\begin{note}
	The list of such attacker's abilities is referred to as {\em threat model}. Note that in the previous threat model the attacker is quite weak -- she can only read the traffic. If she were for instance able to manipulate the traffic, Alice and Bob would need to introduce another features to their protocol so that they could detect forged messages. We will only consider eavesdropping for now.
\end{note}

Our first intuitive requirements on Alice and Bob's ciphering algorithm could be expressed as follows: no matter what plaintext Alice and Bob encrypt and send over the channel, Eve shall {\em not} be able to
\begin{enumerate}
	\item recover any portion of any plaintext, \label{item:plainrecov}
	\item recover the secret key. \label{item:keyrecov}
\end{enumerate}
The item \ref{item:plainrecov} requirement is also referred to as {\em confidentiality}. Note that key recovery would lead to plaintext recovery as well, on the other hand not necessarily the other way around. Let us give an example of a primitive cipher.

\begin{example}
\label{ex:shift}
	{\em Shift cipher} is an ancient cipher used already by Julius Caesar and it works as follows: it inputs a string of letters from a finite alphabet $\cal A$, maps its letters bijectively to the numbers from $0$ to $|{\cal A}|-1$ and adds a constant $c\in\{\atob{0}{|{\cal A}|-1}\}$ modulo $|\cal A|$ to each number. Finally it maps the numbers back to letters yielding a string ``shifted'' by $c$ where $c$ can be interpreted as an element of $\cal A$ as well. Decryption can be done simply by substracting $c$ from the ciphertext in a similar way.
	
	Shift cipher can be easily broken by pen and paper only since there are as many keys as letters in the alphabet, typically $26$ english letters. You simply try them all until the plaintext makes sense. Such approach is referred to as {\em brute force attack} or {\em exhaustive search}.
\end{example}
\nomenclature{$\mid S\mid$}{Cardinality of the set $S$}

As we could see in the previous example, shift cipher is not much secure cipher. Therefore we would like to formalize the concept of security.

% ======================================================================
% ===   F.                      ===
% ======================================================================

\subsection{Formal Security Requirements}

There are two large families of ciphers -- symmetric and asymmetric. Shift cipher from Example \ref{ex:shift} belongs to the symmetric family which follows from the fact that it uses the same key for both encryption and decryption while asymmetric ciphers use distinct keys for encryption and decryption. Asymmetric ciphers are also referred to as public key ciphers but we will only consider symmetric ciphers in this thesis, a definition follows.

\begin{defn}[Symmetric Cipher]
	Let $K$ denote the key space, $M$ the message space and $C$ the ciphertext space. {\em Symmetric cipher} is a pair of efficiently computable (possibly randomized) functions $(E,D)$, $E:K\times M\rarr C$, $D:K\times C\rarr M$, such that $\forall m\in M, k\in K$ it holds
	\begin{equation}
		%~ \Pr\left(D(k,E(k,m))=m\right) = 1 . \label{eq:correct}
		\Pr\left(D(E(l,k),k)=l\right) = 1 . \label{eq:correct}
	\end{equation}
	%?% \footnote{In some use cases it might be useful to require only so called {\em overwhelming} probability; not needed in this thesis.}
\end{defn}
\nomenclature{$\Pr(\omega)$}{Probability of the event $\omega$}

\begin{note}
	Going back to Example \ref{ex:shift}, the key space is $\{\atob{0}{|{\cal A}|-1}\}\sim\cal A$, the message and ciphertext spaces are ${\cal A}^*$ which stands for the set of all strings over the alphabet $\cal A$.
\end{note}

According to the previous definition, we do not seem to have a definition of a proper cipher at all -- the only requirement is corectness (cf. Equation \ref{eq:correct}) -- but it totally lacks any security requirement. As we will see later, it is actually quite complicated to define ``security'' appropriately.

\subsubsection{Information Security}

Shannon's groundbreaking work \cite{shannon1949mathematical} on the mathematics of communication gives us a tool -- information-theoretic approach. We can then define secure cipher as a cipher which outputs a ciphertext which carries no information about respective plaintext. Note that this can be rewritten in a more friendly form, a definition follows.

\begin{defn}[Perfectly Secure Cipher]
\label{def:perfsec}
	Let $(E,D)$ be a cipher. It is called {\em perfectly secure} if $\forall m_0,m_1\in M$ such that $|m_0| = |m_1|$ and $\forall c\in C$ it holds $\Pr\left(E(k,m_0)=c\right) = \Pr\left(E(k,m_1)=c\right)$ where $k\unirand K$.
\end{defn}

\begin{note}
\label{note:indist}
	In other words, the adversary is not able to {\em distinguish} encryption of $m_0$ from encryption of $m_1$ by {\em any} means.
\end{note}

There is a cipher which is perfectly secure, see the following example.

\begin{example}[Vernam cipher]
	Let $K = M = C = \{0,1\}^n$ and $k\unirand K$. Given a plaintext $m$, {\em Vernam cipher} applies bitwise XOR of the key $k$ yielding ciphertext $c$ i.e. $c = m\xor k$.
\end{example}

\begin{note}
	Vernam cipher is also referred to as {\em One Time Pad} (OTP). Note that it is crucial that each key is only used once otherwise you can attack the cipher easily: given two ciphertexts using the same key $c_0=m_0\xor k$ and $c_1=m_1\xor k$, one can compute $c_0\xor c_1 = m_0\xor m_1$. This can be practically attacked using some apriori knowledge about plaintexts (e.g. encoding (ASCII), format and language of plaintext (XML and english) and so on) which reduces the amount of possibilities and typically leads to complete plaintext recovery.
\end{note}

Perfect security seems to be exactly what we want from a secure cipher but the following theorem shows that it implies certain inconveniences.

\begin{thm}
	Let $(E,D)$ be a perfect cipher. Then $|K| \geq |M|$.
\end{thm}

This consequence seems to go against our intention -- we would like to establish a shared secret key of a limited length and then, using the key, be able to encrypt as much information as we want. For this reason we need to weaken our security assumption. Note that previously there was no assumption on adversary's computing power -- the requirement was actually to hide plaintext from {\em any} adversary i.e. including an adversary with unlimited computing power.

\subsubsection{Computational Security}

We would like to utilize the fact that the adversary typically does not have unlimited computing power but can rather solve only polynomial problems. For this reason we need to change our requirement on ciphertext from ``carries no information'' to ``is computationally impossible to gain some information''. As stated in Note \ref{note:indist}, we would like to make impossible to distinguish which plaintext has been encrypted. We present this idea in the following game.

\begin{game}
\label{game:semsec}
	There are two parties -- a {\em challenger} and an {\em adversary}. First, the challenger chooses a random key $k\unirand K$ and a random bit $b\unirand\{0,1\}$. Then the adversary sends two equally long plaintexts $m_0$, $m_1$ of her choice to the challenger. The challenger then encrypts $m_b$ (according to $b$ she has chosen) and sends the resulting ciphertext $c$ back to the adversary.
	
	The aim of the adversary is to distinguish effectively which $b$ has been chosen by the challenger.
\end{game}
%!% a figure of the game

\begin{note}
\label{note:semsec}
	Resistency of a cipher to this kind of attack is referred to as {\em semantic security}.
\end{note}

Before we give a formal definition, let us introduce some notion first.

\begin{defn}[Negligible Function]
\label{def:neglfunc}
	Let $\epsilon:\N\rarr\R$. $\epsilon$ is called {\em negligible} if $\forall d\in\N$ $\exists \lambda_0\in\N$ such that $\forall \lambda>\lambda_0$ it holds $\epsilon(\lambda)\leq\frac{1}{\lambda^d}$. In the opposite case, $\epsilon$ is called {\em non-negligible}.
\end{defn}
\nomenclature{$\N$}{Positive integers}
\nomenclature{$\R$}{Real numbers}

\begin{defn}[Overwhelming Function]
\label{def:overwh}
	Let $\epsilon:\N\rarr\R$. $\epsilon$ is called {\em overwhelming} if $1-\epsilon$ is negligible.
\end{defn}

\begin{note}
\label{note:neglconst}
	In practice, {\em negligible} is often used with concrete constants as well. $\epsilon<\frac{1}{2^{80}}$ is considered negligible i.e. events with such probability are not considered to occur during our lives, on the other hand $\epsilon>\frac{1}{2^{30}}$ is considered non-negligible i.e. it is likely to observe an event with such probability.
\end{note}

%~ Now we have a reasonable meter for security.

\begin{defn}[Oracle]
	Let $F:X\rarr Y$. {\em Oracle evaluating $F$} is a device which, given $x\in X$, evaluates and returns $F(x)$ in unit time.
\end{defn}

\begin{defn}[Statistical Test]   %!% security parameter? effective in terms of what?
	Let $F:X\rarr Y$. {\em Statistical test} is a (possibly randomized) effective algorithm $A$ which only has an access to an oracle evaluating $F$ and which outputs $0$ or $1$, denoted by $A(F)$.
\end{defn}

\begin{note}
	Statistical test will be also referred to as {\em adversary}.
\end{note}

\begin{defn}[Advantage]
\label{def:advant}
	Let $\cal F$, $\cal G$ be two distinct subsets of the set of all functions from $X$ to $Y$ and $A$ an adversary. We define {\em advantage} of adversary $A$ as
	\[
		\Adv(A,{\cal F},{\cal G}) = \left| \Pr\limits_{F\unirand {\cal F}}\bigl(A(F)=1\bigr) - \Pr\limits_{G\unirand {\cal G}}\bigl(A(G)=1\bigr) \right| .
	\]
\end{defn}

In other words, advantage tells us how likely adversary $A$ is able to distinguish a random function from one set of functions from a random function from another set based on their input/output behavior only. According to these sets, advantage can be ``customized'' for a specific purpose. Let us define such advantage for an adversary tempting to distinguish which of her plaintexts has been encrypted i.e. tells us how likely she is to win the Game \ref{game:semsec}.

\begin{defn}[Semantic Security Advantage]
\label{def:ssadvant}
	Let $E: K\times M\rarr C$ be an encryption function of a symmetric cipher, $k\unirand K$, ${\cal E}_b = \{E_b:M^2\rarr C \mid E_b(m_0,m_1) = E(k,m_b)\}$ for $b=0,1$ and $A$ an adversary. We define {\em semantic security advantage} of adversary $A$ as
	\[
		\AdvSS(A,E) = \Adv(A,{\cal E}_0,{\cal E}_1) .
	\]
\end{defn}

Semantic security gives us a formalization of Game \ref{game:semsec}. We use this to define another notion of security.

\begin{defn}[Semantically Secure Cipher]
\label{def:semsec}
	Let $(E,D)$ be a symmetric cipher. Then it is called {\em semantically secure} if for {\em any} adversary $A$ the semantic security advantage $\AdvSS(A,E)$ is negligible.
\end{defn}



------------------------------------------------------------------------


%!% kecy jak se od SS dostanu k block cipher: jsou stream a block, block potřebujou módy, stream inicializaci, a co že jsou to ty block? pojdme na to s definicí:
Here we justify why we wanna introduce block ciphers\ldots

%!% uplně smazat jakoukoliv zmínku o PRF, nemá smysl a dělá bordel
\begin{defn}[Pseudorandom Function]   %!% $|k|$ polynomial w.r.t. $|x|$
	Let $F: K\times X\rarr Y$. We call $F$ a {\em pseudorandom function} (PRF) if there exists an efficient algorithm which evaluates $F$.
\end{defn}

\begin{defn}[Pseudorandom Permutation]
	Let $E: K\times X\rarr Y$. We call $E$ a {\em pseudorandom permutation} (PRP) if there exists an efficient algorithm which evaluates $E$, the function $E(k,\cdot): X\rarr Y$ is a bijection and there exists an efficient algorithm to compute $E^{-1}(k,\cdot)$ for every $k\in K$.
\end{defn}

\begin{note}
	If a function is a PRP then it is a PRF as well.
\end{note}

Pseudorandom permutations will play the main role from now and $k$ the role of their key. In order to achieve semantic security of certain constructions using a PRP, we need the PRP to behave like a truly random bijection i.e. indistinguishable from each other. Let us demonstrate a possible approach on another game similar to Game \ref{game:semsec}.

\begin{game}
\label{game:prp}
	There are two parties -- a {\em challenger} and an {\em adversary}. Let $E:K\times X\rarr Y$ be a PRP. First, the challenger chooses a random key $k\unirand K$, a random bijection $F:X\rarr Y$ and a random bit $b\unirand\{0,1\}$. Then the adversary sends $x\in X$ of her choice to the challenger. The challenger then applies $E(k,\cdot)$ or $F$ if $b=0$ or $1$, respectively, and sends the result back to the adversary.
	
	The aim of the adversary is to distinguish effectively which $b$ has been chosen by the challenger.
\end{game}

% přiblížit kecům co následujou první game
Before we give a formal definition of a secure PRF and PRP, we define adversary's advantage in the previous game in a manner analogous to Definition \ref{def:ssadvant}.

\begin{defn}[PRP Advantage]
\label{def:prpadvant}
	Let $E: K\times X\rarr Y$ be a PRP, $\cal P$ the set of all bijections from $X$ to $Y$ and $A$ an adversary. We define {\em PRP advantage} of adversary $A$ as
	\[
		\AdvPRP(A,E) = \Adv(A,\{E(k,\cdot)|k\in K\},{\cal P}) .
	\]
\end{defn}

% přiblížit kecům co následujou první game
PRP advantage tells us how likely adversary $A$ is able to distinguish a PRP with a random key from a truly random bijection based on its input/output behavior only. The definition of secure PRP follows.

\begin{defn}[Secure PRP]
\label{def:secprp}
	Let $E: K\times X\rarr Y$ be a PRP and $\cal P$ the set of all bijections from $X$ to $Y$. $E$ is called {\em secure PRP} if for {\em any} adversary $A$ the advantage $\Adv(A,F,{\cal P})$ is negligible.   %!% negligible in terms of what?
\end{defn}

% přiblížit kecům co následujou první game
In other words, PRP given a random key is secure if it is computationaly indistinguishable from a truly random bijection. Secure PRP is what we call a {\em block cipher}. An example covering most introduced concepts follows.

\begin{example}
	Let $E:\{0,1\}^{128}\times\{0,1\}^{128}\rarr\{0,1\}^{128}$ be a PRP defined as
	\[
		E(k,x) = \bin\bigl((k)_2 + (x)_2 \mod{2^{128}}\bigr)
	\]
	where $\bin(\cdot)$ stands for number's $128$-bit binary representation and $(\cdot)_2$ stands for a number represented by given binary string.
	
	Now let us construct an adversary $A$ as follows: it generates two arbitrary but distinct $x_0,x_1\in\{0,1\}^{128}$ and feeds them to an oracle computing either PRP $E$ or a truly random bijection. The oracle returns $y_0$ and $y_1$, respectively, and the adversary compares values $(y_i)_2 - (x_i)_2 \mod{2^{128}}$ for $i=0,1$ with each other. If these values are equal, $A$ returns $1$, $0$ otherwise.
	
	Note that if the oracle computes PRP $E$ then these values are always equal. Otherwise, i.e. the oracle computes a truly random bijection, the values are distinct with overwhelming probability. Therefore the PRP advantage of such adversary is
	\[
		\AdvPRP(A,E) = \left| \Pr\limits_{k\unirand \{0,1\}^{128}}\Bigl(A\bigl(E(k,\cdot)\bigr)=1\Bigr) - \Pr\limits_{P\unirand {\cal B}}\Bigl(A(P)=1\Bigr) \right| = 1 - \epsilon
	\]
	where $\cal B$ stands for the set of all bijections on $\{0,1\}^{128}$ and $\epsilon$ is negligible.
	
	It follows that such PRP is totally insecure since there exists an attacker with overwhelming advantage and only non-negligible advantage is required to break the PRP.
\end{example}

------------------------------------------------------------------------
\begin{note}
	Note that in previous definitions we had to limit adversary's access to the oracle to one otherwise there is a trivially winning adversary. Indeed, such adversary picks three distinct plaintexts $m_0$, $m_1$, $m_2$ (well, let us suppose there are at least three plaintexts in $M$) and sends $(m_0,m_1)$ to the challenger, she gets back some ciphertext $c_a$. In her second query, the adversary sends $(m_0,m_2)$ to the challenger and receives another ciphertext, let say $c_b$. Since PRP is a deterministic bijection, she can decide with certainty:
	\begin{itemize}
		\item $b=0$ if $c_a = c_b$, or
		\item $b=1$ if $c_a \neq c_b$.
	\end{itemize}
	
	Therefore it is clear that if we wanted semantic security with respect to an adversary with unlimited access, the encryption would {\em have to} encrypt the same plaintext differently each time. This can be achieved using randomization or counters. In case of block ciphers this leads to {\em modes of operation}, e.g. Cipher Block Chaining (CBC) mode or Counter (CTR) mode, but this is out of the scope of this thesis.
\end{note}
------------------------------------------

% uplně do háje...
So far we have two distinct notions of security -- we have {\em secure PRP} according to Definition \ref{def:secprp} and {\em semantically secure PRP} according to Definition \ref{def:semsecprp}. And there is a relation between them as stated in the following theorem.

\begin{thm}
	Let $E: K\times X\rarr Y$ be a secure PRP. Then it is also a semantically secure PRP.
\end{thm}
\begin{proof}
	We show that for every semantic security adversary $A$ (i.e. an adversary distinguishing $E(k,m_0)$ from $E(k,m_1)$) there exist security adversaries $B_0$, $B_1$ (i.e. adversaries distinguishing PRPs from truly random ones) such that
	\begin{equation}
	\label{eq:aleqbb}
		\AdvSS(A,E) \leq \AdvPRP(B_0,E) + \AdvPRP(B_1,E) .
	\end{equation}
	The claim follows -- if $E$ is a secure PRP i.e. $\AdvPRP(B_0,E) + \AdvPRP(B_1,E)$ is negligible then also $\AdvSS(A,E)$ is negligible therefore $E$ is semantically secure.
	
	Let us first denote $W_b$ the event when adversary answers $1$ while the true value of the semantic security game with PRP $E$ is $b$ for $b=0,1$. In this notation it holds
	\[
		\AdvSS(A,E) = \left| \Pr(W_1) - \Pr(W_0) \right| .
	\]
	
	Let us further denote $R_b$ the same event with only difference -- the semantic security game uses a random bijection instead with advantage denoted $\AdvSS'(A)$. It holds
	\[
		\AdvSS'(A) = \left| \Pr(R_1) - \Pr(R_0) \right| = 0
	\]
	since $b\unirand\{0,1\}$ and both $R_b$ provide a truly random bijection independent from $b$.
	
	Now we construct adversaries $B_0$, $B_1$ distinguishing PRPs from truly random ones while we make use of adversary $A$.
	
	Let us construct $B_0$ first. We ask $A$ to provide $m_0$ and $m_1$, then we feed the oracle with $m_0$ obtaining $c$ as a result. Note that either $c=E(k,m_0)$ or $c=F(m_0)$ according to $b$ where $F$ is a truly random bijection. We provide this $c$ to adversary $A$ and output what $A$ outputs. Now the advantage of such adversary is
	\[
		\AdvPRP(B_0,E) = \left| \Pr(W_0) - \Pr(R_0) \right| .
	\]
	
	We construct $B_1$ in a similar manner and get
	\[
		\AdvPRP(B_1,E) = \left| \Pr(W_1) - \Pr(R_1) \right| .
	\]
	
	Finally we get
	\[
		\AdvPRP(B_1,E) = \left| \Pr(W_1) - \Pr(R_1) \right|
	\]
	which proves Equation \ref{eq:aleqbb} which was to be proved.
\end{proof}

\begin{note}
	A semantically secure PRP does not need to be a secure PRP. Indeed, let $E: K\times X\rarr Y$ be a secure PRP and define $E'(k,x) = E(k,x)|1$. Obviously $E'$ is semantically secure i.e. it remains hard to distinguish encryptions but it can be easily distinguished from a truly random bijection since it always ends with $1$.
\end{note}

% no a nějak navázat
Semantic security is usually what we rather require from a secure cipher. Note that secure PRP might be too strong requirement: ...

% pokračovat, dát příklad, block cipher že je spíš teda secure PRP, semantic security vhodná do secure communication

\subsubsection{Provable vs. Real-World Security}

Note that there is no provably secure block cipher known; if there were, it would actually imply that $\Pclass \subsetneq \NPclass$ which is an open millenium problem. Indeed, if $\Pclass = \NPclass$ and $F$ were a secure PRP then adversary could, given a certain (polynomial) amount of plaintext-ciphertext pairs $(pt_i,ct_i)$, look for a key $k$ such that $ct_i = F(k,pt_i)$ for all $i$. Then she would simply answer ``truly random'' if no such $k$ exists, otherwise she says ``pseudorandom''. Here the ``truly random'' answer is sure while the ``pseudorandom'' answer is just a conjecture but with sufficiently large probability.
\nomenclature{$\Pclass$}{Deterministic polynomial complexity class i.e. the set of decision problems which can be solved by a deterministic Turing machine in polynomial time}
\nomenclature{$\NPclass$}{Non-deterministic polynomial complexity class i.e. the set of decision problems which can be solved by a non-deterministic Turing machine in polynomial time}

Instead, real-world block ciphers are {\em beleived} to be secure based on a simple fact: no known attack is far better than exhaustive search. One such block cipher is called {\em AES} and will be of top interest in this thesis. AES will be described in detail in Section \ref{sec:aes}.


% ======================================================================
% ===   W H I T E - B O X   A T T A C K   C O N T E X T              ===
% ======================================================================

\subsection{White-Box Attack Context}

The other central topic of this thesis is {\em white-box attack context}. In order to explain what it is, let us introduce {\em black box attack context} first.

\subsubsection{Black Box}

%!% přepsat, game už umim
Black box can understood like an oracle -- given an input, it provides an output in a unit time. Thus we do not get any other information but input-output pairs. Note that black box attack context was considered during the design of most ciphers; for example straightforward AES implementation is totally insecure if certain byproducts or even some information related to them is revealed. An attack exploiting such information leaks is covered in detail in Section \ref{sec:side}.

%!% přesun do přechozí sekce, přidat hru i před secure PRF/PRP



%~ Note that if a block cipher is secure then such advantage is also negligible.

% implementation can help, e.g. timing attacks
% RSA, an asymmetric cipher, could serve as a good example

% black box: like an oracle, everything holds. ciphers designed wrt black box, why wb? what it is? ...

\begin{defn}
	
\end{defn}

\begin{defn}
	
\end{defn}





%~ \subsubsection{Black-Box Model}
	
	%~ approach: feistel, iterated; diffusion vs. confusion




%~ odpad:

%~ \subsection{Pseudorandomness}
%~ \begin{defn}
	%~ PRG is a function $G:\{0,1\}^s\rarr\{0,1\}^n$ such that $n>>s$. It input is referred to as {\em seed}.
	%~ % eff. computable by a determ. algorithm
%~ \end{defn}

%~ Note that OTP using PRG (called stream cipher) can never have perfect secrecy since the key length is smaller than message length. Need for different definition. Security lies in PRG ``unpredictability''.

%~ Predictable means: $\exists i$ s.t. given $G(k)|_{\atob{1}{i}}$, there exists an efficient algorithm which can compute $G(k)|_{\atob{i+1}{n}}$ ... CPA using $i$ bits would lead to plaintext recovery.
%~ 
%~ Predictable (2): $\exists eff. alg. A$ and $\exists i<n$ s.t. $Pr(A(G(k)|_{\atob{1}{i}}) = G(k)|_{i+1}) > 1/2 + \epsilon$ for non-negligible $\epsilon$. ... unpredictable iff it's not predictable.
%~ 
%~ Example: linear congruence generator:
%~ r[i] = a . r[i-1] + b mod p
%~ output bits of r[i]
%~ i++
%~ repeat
%~ ... implemented as random() in glibc, cannot be used in crypto

%~ \begin{defn}
	%~ Let $G_\lambda:K_lambda\rarr\{0,1\}^{n(\lambda)}$ be a PRG parameterized by $\lambda\in\N$, $i\in\N$, $i<n(\lambda)$ and $\epsilon$ a non-negligible function. We say that $G_\lambda$ is {\em predictable} at position $i$ if there exists a polynomial-time algorithm $A$ such that $Pr(A(\lambda, G_\lambda(k)|_{\atob{1}{i}}) = G_\lambda(k)|_{i+1}) > 1/2 + \epsilon(\lambda)$.
%~ \end{defn}
