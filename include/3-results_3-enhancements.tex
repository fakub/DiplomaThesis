\section{Enhancements of the Attack}   %?% to/of ?

WBAES by Chow et al.\ \cite{chow2002aes} has been shown by Klinec \cite{klinec2013white} to be eqivalent to Karroumi's improved version \cite{karroumi2011protecting}. Remind that Karroumi's WBAES uses internally dual AES'es and therefore we cannot recognize which affine mapping has been used inside SBoxes, see Note \ref{note:dualsbox}.

Let us first remind definition of the original SBox (originally Equation \ref{eq:sbox}),
\[
	\defsbox .
\]
Note that the original SBox is a specific affine mapping of Rijndael inverse of its input while in Karroumi's approach, this affine mapping is not fixed. Such a new SBox could be written as
\begin{equation}
\label{eq:spq}
	S_{p,q}(A) = p\cdot A' + q \pmod{x^8+1}
\end{equation}
for $p,q\in F$ and $p$ coprime with $x^8+1$. The simplest affine mapping is obviously for $p=1$ and $q=0$ which yields $S_{1,0}(A) = A'$ i.e.\ only a Rijndael inverse.

\begin{remark}
\label{rem:coprime}
	The reason why $p$ must be coprime with $x^8+1$ was already given in the definition of the original SBox in Note \ref{note:sboxinv} -- it was due to its invertibility. Hence we would like to test whether $p$ is coprime with $x^8+1$.
	
	Note that $x^8+1 = (x+1)^8$, therefore if $p$ is not coprime with $x^8+1$, then $1$ must be its root, and vice versa. This can be easily tested, indeed $p(1) = 0$ if the number of its terms is even. It follows that $p$ is coprime with $x^8+1$ if and only if the number of terms of $p$ is odd.
\end{remark}


% ==============================================================================
% ===   C H A N G I N G   A T T A C K   T A R G E T                          ===
% ==============================================================================

\subsection{Changing Attack Target}

Since all of these SBoxes are equivalent inside WBAES, Bos et al.\ came up with the idea of changing the target\footnote{The word {\em target} will be heavily used in this context. Do not be confused with {\em target bit}, it keeps the original meaning.} of the attack from the original SBox to its simplest variant -- Rijndael inverse.

\begin{remark}
\label{rem:spq}
	Technically we only substitute SBoxes on Line \ref{line:s0} and \ref{line:s1} of Algorithm \ref{alg:bitwisedpa} with their desired variant, hence yielding
	\begin{align*}
		S_0 &\gets \Bigl\{ Traces[n] \Bigm| S_{p,q}\bigl(KGuess\xor PTs[n][i]\bigr)[j] = 0 \Bigr\} , \\
		S_1 &\gets \Bigl\{ Traces[n] \Bigm| S_{p,q}\bigl(KGuess\xor PTs[n][i]\bigr)[j] = 1 \Bigr\} .
	\end{align*}
	Remind that we always use precomputed SBox tables as already stated in Remark \ref{rem:attacklookup}.
\end{remark}

We conducted the same attack as in Section \ref{sec:klinecwbaes}, now with Rijndael inverse as the target, see results in Table \ref{tab:klinecrijinv}.

\begin{landscape}
\begin{table}[H]
	\begin{center}
	\input{./tables/3_3_1-klinec-rijinv.tex}
	\end{center}
\caption{Bit-Wise DPA attack against {\tt KlinecWBAES} using $1024$ traces, Rijndael inverse taken as the target.}
\label{tab:klinecrijinv}
\end{table}
\end{landscape}

In both cases (see results in Table \ref{tab:klinecsbox} and \ref{tab:klinecrijinv}), there are, for each key byte, usually either only few target bits which actually leak, or nothing leaks at all (e.g.\ \nth{9} byte in Table \ref{tab:klinecsbox} cannot be considered as leaking, since the gap is very small at \nth{7} bit and at \nth{8} bit the gap is much larger for an incorrect candidate; this happens much more often if less traces are used). The most substantial practical benefit of attacking different targets is that those key bytes, which did not leak with one target, may possibly leak with another, cf. \nth{9} byte in both tables.


% ==============================================================================
% ===   C O N S I D E R I N G   A N O T H E R   T A R G E T S                ===
% ==============================================================================

\subsection{Considering Another Targets}
\label{sec:16targets}

This benefit led us to the idea of using yet another invertible affine mappings besides the one of the original SBox and identity. There seems to be plenty of them: number of $p$'s is equal to the number of binary polynomials with degree smaller than $8$ which are coprime with $x^8+1$, there are $128$ of them (follows from Remark \ref{rem:coprime}). Number of $q$'s is simply $256$, hence altogether there are $128\cdot 256 = 32\,768$ invertible affine mappings.

\begin{remark}
\label{rem:pqeffect}
	We realized that there are certain classes of mappings which give similar or even same results.
	\begin{description}
		\item[Effect of $q$'s.]
			First let us see what happens if we change one bit of $q$ (here considered as a byte). It obviously only changes the output of our SBox at the same bit, finally yielding a swap of $S_0$ and $S_1$ in the attack algorithm (only at this target bit, of course). Note that this swap has no effect on results, since we are only interested in absolute difference of means of values inside $S_0$ and $S_1$. We will consider $q = 0$, hence our SBoxes will be linear mappings of Rijndael inverse.
		
		\item[Effect of $p$'s.]
			Second let us study the effect of different $p$'s. Note that $x$ is coprime with $x^8+1$ and $p$ is supposed to, therefore if we multiply $p$ by $x\pmod{x^8+1}$, the result is still coprime with $x^8+1$.
			
			Now let us see what multiplying by $x\pmod{x^8+1}$ actually does. If the result does not need to be reduced, it simply shifts coefficients of $p$ by one, e.g.\ $(x^4 + x + 1) \cdot x = x^5 + x^2 + x$. If it reaches $x^8$, e.g.\ $(x^7 + x^4 + x^3) \cdot x \pmod{x^8+1} = x^5 + x^4 + 1$, we get $1$ at the end so the shift is actually a cyclical shift.
			
			Remind that polynomials coprime with $x^8+1$ have even number of terms (see Remark \ref{rem:coprime}), hence repeating this we obtain $8$ distinct polynomials which we put in single equivalence class i.e.\ we get $128/8=16$ such classes, see Table \ref{tab:classrepre} for representants of each class. Note that the effect is the same on bits representing polynomials.
			
			Since we assumed $q = 0$, the actual output of two sboxes using $p$'s from single class is thus also only a cyclical shift of each other. It follows that the effect on results is that it only cyclically shifts the results among target bits. Hence also the information which target bit leaks is totally irrelevant.
	%?% neni zas tak irelevant ptž z pozice v trace zjistim která varianta to je, ze všech mi to pak může něco prozradit
	% => je irrelevant ptž ikdyž leaknou dva tak rozhodně nejsou od sebe jak by měly
	% original SBox is {\tt 1f}
	\end{description}
\end{remark}

\begin{table}[h]
	\begin{center}
	\begin{tabular}{| c | c | c | c | c | c | c | c |}
		\hline
		{\tt 01} & {\tt 07} & {\tt 0b} & {\tt 0d} & {\tt 13} & {\tt 15} & {\tt 19} & {\tt 1f} \\
		\hline
		{\tt 25} & {\tt 2f} & {\tt 37} & {\tt 3b} & {\tt 3d} & {\tt 57} & {\tt 5b} & {\tt 7f} \\
		\hline
	\end{tabular}
	\end{center}
\caption{Representants of classes of $p$'s in hexadecimal form.}
\label{tab:classrepre}
\end{table}


% ==============================================================================
% ===   A T T A C K   U S I N G   A L L   1 6   T A R G E T S                ===
% ==============================================================================

\subsection{Attack Using All 16 Targets}

We attacked {\tt KlinecWBAES} using all of the $16$ attack targets and $1024$ traces, see results of \nth{1} byte in Table \ref{tab:lintargets}. Note that the row of target {\tt 01} is equal to the row of \nth{1} byte in Table \ref{tab:klinecrijinv} and the row of target {\tt 1f} is equal to the row of \nth{1} byte in Table \ref{tab:klinecsbox}. This is not a coincidence since {\tt 01} is an identity, therefore the target is plain Rijndael inverse, and {\tt 1f} is the $p$ of the original SBox and $q$ does not have any effect on results, see Remark \ref{rem:pqeffect}. Also note that the target {\tt 25} does not unravel the \nth{1} key byte even with $1024$ traces -- here we can clearly see the benefit of having many targets.

\begin{landscape}
\begin{table}[H]
	\begin{center}
	\input{./tables/3_3_2-invertible-targets.tex}   %!% předělat na odstíny šedi
	\end{center}
\caption{Bit-Wise DPA attack against {\tt KlinecWBAES} using $1024$ traces and all $16$ targets.}
\label{tab:lintargets}
\end{table}
\end{landscape}


% ==============================================================================
% ===   N O N - I N V E R T I B L E   A F F I N E   M A P P I N G S          ===
% ==============================================================================

\subsection{Non-Invertible Linear Mappings}
\label{sec:noninv}

Another surprising results emerged with the idea of trying to use also non-invertible linear mappings in the attack targets. Remind that the mappings were originally required to be invertible, otherwise the resulting cipher would not be invertible. But there is no such limitation on attack target -- actually the attack is only required to work, no matter why.

As before, we only kept one representant of each class where elements are a multiple of $x^i\pmod{x^8+1}$ of each other, for some $i$. See these representants in Table~\ref{tab:classreprenoninv}.

\begin{table}[h]
	\begin{center}
	\begin{tabular}{| c | c | c | c | c | c | c | c | c | c |}
		\hline
		{\tt 00} & {\tt 03} & {\tt 05} & {\tt 09} & {\tt 0f} & {\tt 11} & {\tt 17} & {\tt 1b} & {\tt 1d} & {\tt 27} \\
		\hline
		{\tt 2b} & {\tt 2d} & {\tt 33} & {\tt 35} & {\tt 3f} & {\tt 55} & {\tt 5f} & {\tt 6f} & {\tt 77} & {\tt ff} \\
		\hline
	\end{tabular}
	\end{center}
\caption{Representants of classes of non-invertible $p$'s in hexadecimal form.}
\label{tab:classreprenoninv}
\end{table}

We can immediately discard {\tt 00}, because it only gives $0$ (everything would fall into $S_0$ in the attack algorithm). Let us further see what the other extreme value {\tt ff} gives. It actually gives a sum of all eigth cyclical shifts, therefore it gives {\tt ff} if Hamming weight of Rijndael inverse is odd, {\tt 00} otherwise. One might want to discard {\tt ff} as well, but it has surprisingly shown to be a competitive target. See results in Table~\ref{tab:noninvtargets}.

Note that some targets only have partial results, e.g.\ $\texttt{11} = x^4+1$. This is because $\texttt{11}\cdot x^4 \pmod{x^8+1} = \texttt{11}$, hence the results would be the same in the second half. Remind that multiplication by $x\pmod{x^8+1}$ causes cyclical shift of results.

\begin{landscape}
\begin{table}[H]
	\begin{center}
	\input{./tables/3_3_3-noninvertible-targets.tex}
	\end{center}
\caption{Bit-Wise DPA attack against {\tt KlinecWBAES} using $1024$ traces and non-invertible targets.}
\label{tab:noninvtargets}
\end{table}
\end{landscape}


% ==============================================================================
% ===   L I N E A R   M A P P I N G S   O V E R   G F ( 2 )                  ===
% ==============================================================================

\subsection{Considering Linear Mappings on $\GF(2)^8$ Over $\GF(2)$}

Let us consider bytes as elements of the vector space $\GF(2)^8$ over $\GF(2)$, denoted by $\cal B$. Note that previously we only used an equivalent of a specific subset of linear mappings on $\cal B$. These were generated by polynomial multiplication$\pmod{x^8+1}$, see Equation \ref{eq:spq} where $q$ was later set equal to zero. In such case we only had $256$ linear mappings (one for each element of $\GF(2)^8$ and nothing else).

But there are obviously many more linear mappings on $\cal B$. Let us see how our previously considered mappings can be expressed here -- they correspond with matrices with cyclically shifted rows as outlined in the following example.

\begin{example}
\label{ex:shiftmatrix}
	Let us consider multiplication by $\texttt{3d}\pmod{x^8+1}$; $\texttt{3d} = x^5+x^4+x^3+x^2+1 \sim 00111101$.
	\begin{align*}
		\texttt{3d} \cdot A \mod{x^8+1} &= (x^5+x^4+x^3+x^2+1) \cdot (a_7x^7+\ldots+a_1x+a_0) \mod{x^8+1} = \\
		&= (a_7+a_5+a_4+a_3+a_2)\cdot x^7 + ~\\
		&\quad\vdots \\
		&\quad + (a_7+a_6+a_5+a_4+a_1)\cdot x + ~\\
		&\quad + (a_6+a_5+a_4+a_3+a_0)\cdot 1 \sim \\
		&\sim
		\begin{pmatrix}
			10111100 \\
			01011110 \\
			00101111 \\
			10010111 \\
			11001011 \\
			11100101 \\
			11110010 \\
			01111001 \\
		\end{pmatrix}
		\cdot
		\begin{pmatrix}
			a_7 \\ \vdots \\ a_1 \\ a_0
		\end{pmatrix}.
	\end{align*}
\end{example}

One may wonder whether we have yet another set of targets, but actually we do not. Indeed, let us take a matrix $\mathbb{A}$ of an arbitrary linear mapping and observe $j$-th bit of output, let us suppose that $j$-th row of $\mathbb{A}$ is non-zero. Then $j$-th bit of output is a scalar product of this row with the input.

Since the attack performs bit-wise, the result does not depend on any other bit of output, we only consider $j$-th target bit in the attack for now. But note that there exists very the same row in some of our previously used linear mappings considered as a matrix over $\GF(2)$, let say on $i$-th row of matrix $\mathbb{B}$. Indeed, we used all possible bytes and their equivalence classes were just inner cyclical shifts. So if we attack $i$-th target bit using $\mathbb{B}$, we obtain exactly the same results as with $j$-th target bit using $\mathbb{A}$. Hence we can only consider the row for a new attack target.
%!% trochu bordel v tom co je target -- jestli výsledek p \cdot A' nebo jenom p

Note that we have $255$ of such non-zero rows and the output of this kind of target is a scalar product of this row with Rijndael inverse of input, hence not a byte anymore, but a single bit. Let us denote this mapping by
\begin{equation}
\label{eq:tba}
	T_B(A) = [B]^T\cdot [A'] ,
\end{equation}
where $B$ stands for the row, $A'$ for Rijndael inverse of $A$ and $[\cdot]$ for column vector representation, hence both are scalar-multiplied. Also note that there are indeed $255$ entries altogether in Table \ref{tab:lintargets} and \ref{tab:noninvtargets}, for each byte.

This observation therefore does not bring anything new, but a unifying and simplifying approach. Hence we do not give any results since these are already given in Table \ref{tab:lintargets} and \ref{tab:noninvtargets}. We only wondered whether we should split our remarks in the following Section \ref{sec:remarks} by the origin of the linear mapping (i.e.\ either invertible, or non-invertible) and finally decided to do so, because there could possibly emerge some surprising results.

\subsubsection{Implementation Note}
	
	Now, as we have $255$ targets outputting only a single bit, we have to modify our attack (i.e.\ Algorithm \ref{alg:bitwisedpa}). We skip the forcycle on Line \ref{line:tbcycle} and alter also the following Line \ref{line:s0} and \ref{line:s1} into the following form:
	\begin{align*}
		S_0 &\gets \Bigl\{ Traces[n] \Bigm| T_B\bigl(KGuess\xor PTs[n][i]\bigr) = 0 \Bigr\} , \\
		S_1 &\gets \Bigl\{ Traces[n] \Bigm| T_B\bigl(KGuess\xor PTs[n][i]\bigr) = 1 \Bigr\} ,
	\end{align*}
	where $T_B$ is the mapping from Equation \ref{eq:tba}. For this reason we precompute all $255$ lookup tables for $T_B$'s, of course.
	

% jak jednoduše nagenerovat vše: ...

% a že já tám mam všechny možný řádky všelijak možně posunutý, tak asi nic jinýho nevymyslim, což?
% a vůbec, všechny targety dostanu tim, že přenásobim vstup maticí
%~ 1 0 0 0 0 0 0 0
%~ 0 1 0 0 0 0 0 0
%~ ...
%~ 0 0 0 0 0 0 0 1
%~ 1 1 0 0 0 0 0 0
%~ 1 0 1 0 0 0 0 0
%~ ...
%~ 0 1 1 0 0 0 0 0
%~ ...
%~ 0 0 0 0 0 0 1 1
%~ 1 1 1 0 0 0 0 0
%~ ...
%~ 1 1 1 1 1 1 1 1
% ta už obsahuje bezpečně všechno a dost snadno se generuje

%!% nápad: podle toho co vidim v memtrace, neni lepší útočit na 0x........??..; na 0x.........??. nebo dokonce na 0x........???? místo 0x..........??
% to je ale asi uplná sračka
