\section{Results}
\label{sec:results}

First of all, we used our toolkit to attack our straightforward C++ implementation of AES, here named {\tt naiveAES}, which served just as a proof-of-concept, see results in Section \ref{sec:naiveaes}. Note that the section does not fully cover many details, these are given separately later.

Then we performed the most interesting attack which Bos et al.\ \cite{bos2015differential} did -- we successfuly attacked Klinec's C++ implementation \cite{klinec2013implementation} of WBAES by Chow et al.\ \cite{chow2002aes}, here named {\tt KlinecWBAES}. See results and comments in Section \ref{sec:klinecwbaes}.


% ==============================================================================
% ===   n a i v e A E S                                                      ===
% ==============================================================================

\subsection{\tt naiveAES}
\label{sec:naiveaes}

In order to prove the concept of both SCA algorithms presented in this thesis, we first attacked our straightforward AES implementation {\tt naiveAES} with both of them. Both attacks are expected to work since {\tt naiveAES} stores all intermediate results needed for each attack. For this reason, we captured contents of $1$ byte memory writes in our memory traces and used the original SBox as our target. In both cases we considered strong candidates separately.
%?% remind strong candidates?

\subsubsection{CPA Attack against {\tt naiveAES}}
	
	First we attacked {\tt naiveAES} with CPA attack using $64$, $96$ and $128$ traces, respectively. Our results are given in Table \ref{tab:naiveaescpa}. For each key byte and different number of traces, two values are given in the table: percentual gap of the best candidate to the second candidate and rank of the correct candidate. If we look at the \nth{5} bit back in Table \ref{tab:gap} in Example \ref{ex:gap}, these two values would be $\frac{0.3970-0.3884}{0.3970}\cdot100\%\approx2.2\%$ and $45$, respectively.
	
	\begin{table}[h]
		\begin{center}
		\input{./tables/3_2_1-naiveAES-CPA.tex}
		\end{center}
	\caption{CPA attack against {\tt naiveAES}}
	\label{tab:naiveaescpa}
	\end{table}
	
	It appears that we need order of hundreds of traces in order to attack even an unprotected implementation successfuly. Remind that in CPA attack we only have single attack target (for each key byte) which is Hamming weight of output of the first SBox. However, this attack served just as a proof of concept.

\subsubsection{Bit-Wise DPA Attack against {\tt naiveAES}}
	
	Second we performed bit-wise DPA attack (i.e.\ Algorithm \ref{alg:bitwisedpa}) against {\tt naiveAES} using $24$ and $32$ memory traces, respectively. See results in Table \ref{tab:naiveaesdca} which shows amount of leaking target bits. Note that the maximum value of difference of means of the correct candidate is {\em always} equal to $1.0$ since there is a position where given intermediate product -- here a bit output of the first SBox -- appears. Therefore once there appears a gap for the first time, we know the correct candidate for sure and do not need to care about its strongness.
	
	%!% asi uplně zahodit tabulku a jenom říct, že to poznam hned ptž správnej má dycky 1.0 a jde jenom o to kdy se odlepí poslední špatnej ... zbude jedinej
	\begin{table}[h]
		\begin{center}
		\input{./tables/3_2_2-naiveAES-DCA.tex}
		\end{center}
	\caption{Number of target bits which gave single candidate with difference of means equal to $1.0$ using bit-wise DPA attack against {\tt naiveAES}.}
	\label{tab:naiveaesdca}
	\end{table}
	
	Using $24$ traces has mostly shown to be sufficient and with $32$ traces, our attack was always successful. Note that these numbers are only illustrative, it could possibly happen that many more traces would keep two candidates on the top, both with difference of means equal to $1.0$.
	
	%~ CPA attack required $x$ traces, bitwise DPA attack required $y$ traces.
	%?% vyzkoušet rijinv na naiveAES, nemělo by jít, a taky nejde


% ==============================================================================
% ===   K l i n e c W B A E S                                                ===
% ==============================================================================

\subsection{\tt KlinecWBAES}
\label{sec:klinecwbaes}

The most interesting results came with attacking Klinec's implementation \cite{klinec2013implementation} of WBAES by Chow et al.\ \cite{chow2002aes}.

First we tried to attack {\tt KlinecWBAES} with CPA attack, too, but it did not break any key byte at all. Therefore the rest of our results focuses exclusively on bit-wise DPA attack.

\subsubsection{Bit-Wise DPA Attack against {\tt KlinecWBAES}}
	
	We used $1024$ traces for the attack, see results in Table \ref{tab:klinecsbox}. In this table we give percentual gap of the best candidate to the second candidate together with rank of the true key byte, for each key byte and target bit.
	
	\afterpage{
		\clearpage   % To flush out all floats, might not be what you want
		\begin{landscape}
		\begin{table}[h]
			\begin{center}
			\input{./tables/3_2_3-klinec-sbox.tex}   %!% obrátit pořadí sloupečků !!!
			\end{center}
		\caption{Bit-Wise DPA attack against {\tt KlinecWBAES} using $1024$ traces. Percentual gap of the best candidate and rank of the true key byte is given for each key byte and target bit. Rank of the true candidate goes from $0$ while $0$ (i.e.\ the top position) is replaced with $\blacksquare$ or {\weak$\blacksquare$} in order to be well emphasized, for strong or weak candidate, respectively.}
		\label{tab:klinecsbox}
		\end{table}
		\end{landscape}
	}
	
	On average, there are about $31\%$ of successful strong candidates and about $36\%$ of both weak and strong ones (see Note \ref{note:strong} for strong vs.\ weak candidates).
	
	Compared to the results of Bos et al.\ \cite{bos2015differential}, we successfuly reproduced one half of their attack. The second half is given in Section \ref{sec:rijinv} because it requires some improvements to be introduced.
	
	\begin{note}
	\label{note:tailrank}
		As already noted by the original authors, we can see remarkably many tail ranks (e.g.\ between $250$ and $255$) in results in Table \ref{tab:klinecsbox}.
	\end{note}

% jak dlouho to běželo, že jsem zjistil adresu kde to leakuje


% ==============================================================================
% ===   B a c i n s k a   W B A E S +                                        ===
% ==============================================================================

% proč to s tou javou nešlo:
% neimplementuje AES ale "zlepšenou" verzi
% key-dependent SBoxy => útok tak jak je ani fungovat nemůže
