\section{Blind Attack}
\label{sec:blindattack}

In a real-world scenario, the key is typically unknown. Therefore we do not have any information whether our best candidate is correct or not. We need some rule to deduce so. Note that we can run ordinary AES encryption whenever we want to check our key candidate.

\begin{remark}
\label{rem:false}
	Especially note the attack against the \nth{1} byte using {\tt 3d} as a target and its last but one entry in Table \ref{tab:lintargets} -- here the incorrect candidate has a gap of almost $26\%$. It is actually the largest gap of an incorrect candidate among all targets and all bytes using this particular instance of WBAES tables. The largest gap of an incorrect candidate ever seen was almost $35\%$!
	
	In our results, the target bits keep their original order (but reverse), therefore we can deduce the row $B$ generating the target in terms of $T_B$. Here it is the second row of matrix of multiplication by $\texttt{3d}\pmod{x^8+1}$, see Example \ref{ex:shiftmatrix}. Hence the row is $B = 01011110$.
\end{remark}

For this reason, we studied our results deeper. The following section gives some of our remarks, next we suggest the blind attack itself in Section \ref{sec:subblindattack}


% ==============================================================================
% ===   R E M A R K S                                                        ===
% ==============================================================================

\subsection{Remarks}
\label{sec:remarks}

Obviously we cannot make conclusions based on single {\tt KlinecWBAES} table instantiation only. In order to avoid specific behavior of single instance, we created another $7$ instances, acquired $1024$ traces and ran attack against each key byte using all $255$ targets, for each instance. We processed the results and displayed several statistics. Here we present some of them. Note that we filtered correct candidates with a gap smaller than $5\%$ for this purpose.

\subsubsection{Leaking Bits}
	
	Remind that our trace is a bit-wise serialization of least significant bytes of memory addresses, hence we can identify which bit within that byte leaked -- simply by taking the leaking position within trace modulo $8$. This moduled position will be referred to as {\em leaking bit} (note the difference from target bit).
	
	We noticed soon that leaking bits are not very well balanced, therefore we put this data into a histogram, see Figure \ref{fig:leakbitall}. The histogram shows the amount of correct candidates with a gap larger than $5\%$ averaged over $8$ WBAES instances, for each leaking bit, together with standard deviation which is surprisingly very low. Note that the histogram does not provide absolute values since these could be misleading, only distribution is relevant at the moment.
	
	\begin{figure}[h]
	\begin{center}
		\includegraphics{figures/leak_bit/all.pdf}
		\caption{Average number of leaks and its standard deviation at each leaking bit.}
		\label{fig:leakbitall}
	\end{center}
	\end{figure}
	
	The \nth{0} and \nth{1} bits leaked slightly more, the \nth{2} bit slightly less and the \nth{3} bit actually leaked only twice while the overal average of the remaining bits was almost $160$! On the other hand, all of the remaining bits leaked fairly similarly. We do not have any explanation for this behavior.
	
	We further studied whether there is some influence of target invertibility (non-invertible targets were introduced in Section \ref{sec:noninv}).
	
	\begin{figure}[h]
	\begin{center}
		%!% viz poznámku v datech !!! nepočítalo to vícenásobný leaky non-invertibilních, proto nesedí součty
		\includegraphics{figures/leak_bit/inv_vs_non-inv.pdf}
		\caption{Number of leaks at each bit within trace modulo $8$.}
		\label{fig:leakbitinv}
	\end{center}
	\end{figure}
	
	%!% že tam je furt kotel false positives, referovat, už jsem to zminoval v tom remarku myslim

\subsubsection{Leaks per Target}
	
	And now leaks per target. %!% remake: udělat všech nezávislejch 255 a počítat procentuelně (možností má 16, tak asi ne uplně histogram, ale spíš průměrnej počet leaků na target a nák otestovat uniformitu)
	% asi taky udělat víc útoků s různejma tabulkama ...
	%~ We repeated this attack against all key bytes using $1024$ traces and observed following:
	%~ \begin{itemize}
		%~ \item $12.6$ targets per byte were successful ($\blacksquare$) on average (without any limit on gap),
		%~ \begin{itemize}
			%~ \item the rest gave incorrect candidate ($\boxtimes$),
		%~ \end{itemize}
		%~ \item correct candidates had average gap of $37\%$ with standard deviation of $11\%$,
		%~ \item incorrect candidates had average gap of $13.5\%$ with standard deviation of $4.5\%$,
	%~ \end{itemize}
	%~ We used this information and repeated the attack with only $128$ traces while
	%~ \begin{itemize}
		%~ \item considering only candidates beyond $\mu_\textnormal{false}+3\sigma_\textnormal{false} = 27\%$, we get
		%~ \begin{itemize}
			%~ \item $10.6$ successful targets on average,
			%~ \item no false positive i.e.\ incorrect candidates are filtered out.
		%~ \end{itemize}
	%~ \end{itemize}
	
	\ldots will be changed. Makes no sense
	
	\begin{figure}[h]
	\begin{center}
		\includegraphics{figures/leak_target/plot.pdf}
		\caption{Number of leaks with each target. The number was doubled at {\tt 11}, {\tt 33} and {\tt 77}, fourtupled at {\tt 55} and eighttupled at {\tt ff} to fit the scale.}
		\label{fig:leaktargethist}
	\end{center}
	\end{figure}

\subsubsection{Using Less Traces}
	
	Note that once we use less traces, we usually do not find the correct candidate on the tail (as mentioned in Note \ref{note:tailrank}). Some results \ldots %!% results


% ==============================================================================
% ===   B L I N D   A T T A C K                                              ===
% ==============================================================================

\subsection{Blind Attack}
\label{sec:subblindattack}

\begin{note}
	This section only applies previous observations on a heuristic basis, there is no guarantee that our approach is the best.
\end{note}

We suggest to use less traces and repeat the attack with several targets. Even though we can hardly exploit the observation about candidates on the tail from Note \ref{note:tailrank}, it appears to be more robust and efficient to use several targets and sum the values of their respective best candidates unless filtered.

\ldots


% We rather suggest the following:
%~ \begin{enumerate}
	%~ \item pick a target, %!% Chi-square test of uniformity, pick random
	%~ \item attack using $256$ traces
%~ \end{enumerate}

%~ Therefore, in case of blind attack (i.e.\ no knowledge of actual key), we suggest to use less traces, but keep changing the target until the maximal gap exceeds $27\%$, then we accept that candidate. This is likely to happen soon since $10.6$ out of $16$ targets succeed on average.

% psal já / Teuwen:
%~ > I only wonder about the reasoning why Karroumi is more than Chow since
%~ > it seems to have been shown to be equal (based on what I wrote in my
%~ > previous email).
%~ 
%~ Well I've no problem to break completely Chow with standard DCA so there
%~ is something a bit more in Karroumi. Obviously not enough to make it
%~ robust enough...
